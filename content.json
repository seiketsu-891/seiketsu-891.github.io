{"pages":[{"title":"Leetcode-4-Median of Two Sorted Arrays","text":"Problem statementGiven two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). AnalysisThe straight-forward method is to merge two arrays and find the median. For eample: arr1 = [2,4,6,15] arr2 = [1,7,8,10,12] we merge them and draw a line in the merged array. The item in the left that next to the line we drew is the median. We can find that: to find the median , actually we need to find where to draw the line in the merged array; instead of drawing the line in the merged array, we can draw 2 lines(bound1 and bound2 ) in the 2 input arrays. we need to make sure that : all numbers in the left &lt;= all numbers in the right left_len_arr1 + left_len_arr2 = len_ left_mergedArray ![image-20221217115317853](/Users/wangjingjie/Library/Application Support/typora-user-images/image-20221217115317853.png) If we have found the 2 bound lines and the total length of the 2 input arrays is an odd number, the median would be the maxium number in the left part. If the total length is an even number, then median = ( max number in the left + min number in the right ) / 2 ![image-20221217120120563](/Users/wangjingjie/Library/Application Support/typora-user-images/image-20221217120120563.png) So our goal now is to find the location of two bound lines. Actually, as left_len_arr1 + left_len_arr2 = length of left_mergedArray, if we have found the location of bound1, then bound2 can be easily found. So we just need to find the location of bound1. Or in other words, we need to find the max number in arr1 that meets the constraints below: left_len_arr1 + left_len_arr2 = length of left_mergedArr max_left_arr1 &lt;= min_right_arr2 max_left_arr2 &lt;= min_right_arr1 Let’s say the index of this number is i, the index of the max number in the left in arr2 is j, the length of arr1 is len1, and the length of arr2 is len2, ![image-20221217124636666](/Users/wangjingjie/Library/Application Support/typora-user-images/image-20221217124636666.png) then: i + 1 + j+ 1 = (len1 + len2 +1)/2 arr1[i] &lt;= arr2[j+1] arr2[j] &lt;= arr1[i+1] we can use binary search to find i and j. 12345678910111213while(left &lt;= right){ int i = (left + right)/2; int j = (len1 + len2 ) /2 - i -1; if(nums1[i] &gt; nums2[j+1] ){ // we must make sure nums1 is the shoter array right = i - 1; // search in the left part of item[i] }else if(nums2[j] &gt; nums1[i+1]){ left = i + 1; // search in the right part of item[i] }else{ System.out.println(i); } Answer","link":"/tmp/Leetcode-4-Median-of-Two-Sorted-Arrays.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/12/14/hello-world/"},{"title":"Leetcode 1 Two Sum","text":"question:Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have *exactly* one solution, and you may not use the same element twice. You can return the answer in any order. basic ideaThe simplest but not so efficient method is to iterate the array and for every item in the array, we iterate the items after it and to check if we could get the the sum we want. Time complexity of this method would be O(n^2). So how do we make the solution more efficient? Let’s look at an example. If the input is [2, 11, 15, 6], and the target is 8. We iterate the input array and when the current item is 2, we expect to find 6. we can use a map to save the index of the item 2 and the number we expect to find, which is 6. When the current items becomes 6, we check the map and find it’s just what we wanted. my solution123456789101112131415161718class Solution { public int[] twoSum(int[] nums, int target) { int[] res = new int[2]; Map&lt;Integer, Integer&gt; map = new HashMap(); for(int i = 0; i &lt; nums.length; i++){ int curr = nums[i]; if(i &gt; 0 &amp;&amp; map.containsKey(curr)){ res[0] = map.get(curr); res[1] = i; return res; } map.put(target - nums[i], i); } return res; }} time complexity: O(n) - in the worst scenario, we need to interate the whole array once space complexity: O(n) - we need an extra map","link":"/2022/12/14/Leetcode-1-Two-Sum/"},{"title":"Leetcode-2-Add-Two-Numbers","text":"questionYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. basic idea we need to clarify the problem First. the arguments are LinkedNodes, which basically has 2 properties: value and the next node, the return value is also a LinkedNode. the given intergers are stored in reverse order . ex: arguments 2 -&gt; 3 - 1 and 2-&gt; 1 means 132+ 12 so we can iterate the two nodes, if they all have value, then add them, and store the carry. If one of them does not have value, then make the value of the other node add 0. code123456789101112131415161718192021222324252627282930313233343536373839class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode resHead = null; ListNode prevNode = null; int carry = 0; int sum; while(l1 != null || l2 != null){ int num1 = (l1 != null)? l1.val : 0; int num2 = (l2 != null)? l2.val : 0; sum = num1+ num2 + carry; carry = sum / 10; sum = sum % 10; ListNode newNode = new ListNode(sum); if(resHead == null){ resHead = newNode; }else{ prevNode.next= newNode; } prevNode = newNode; if(l1 != null){ l1 = l1.next; } if(l2 != null){ l2 = l2.next; } } if(carry &gt; 0){ prevNode.next = new ListNode(carry); } return resHead; }}","link":"/2022/12/15/Leetcode-2-Add-Two-Numbers/"},{"title":"Leetcode-3- Longest Substring Without Repeating Characters","text":"Problem statementGiven a string s, find the length of the longest substring without repeating characters. AnalysisThe brute force method is to iterate every character of the string, and for each character we are iterating, iterate the charateres after it. To improve the performance, first think about what extra job do we do in the method metioned above. Let’s say the input string is ‘abcabcbb’, when we are iterating each character: when i = 0 =&gt; we will iterate : abca,(a is duplicated , so we stop here ) when i =1 =&gt; we will iterate : bcab = when i = 2 =&gt; we will iterate: cabc when i = 3 =&gt; we will iterate : abcbb when i = 4 =&gt; we will iterate : bcb …. We can use a picture to show this. As we can see, some characters were iterated several times. we can see each character sequence surrouned by a rectangle as a window, each window = the previous window - its fitst item + other items.. So we can set two pointers - left and right. Each time we encouter a duplicated charactor, we move the left pointer. For example: [a b a e f b g ] At the beginning, left = 0, right =0; then we move the right pointer to the right, when right = 2, we encounter a dulplicated item. So we move the left pointer to make left equals 1 and continue to move the right pointer. At this time, we store the length of this string sequence without repeating characters, which isright-left+ 1 Then we repeat this process. When right = 5, we find a dulplicated ‘b’, so we make left = 2, and continue to move the right pointer. Notice that when we find a duplicated item, we need to make sure that we know where to move our left pointer to, so we need to use a hashtable to store characters and their corresponding index. Code1234567891011121314151617181920212223242526272829303132class Solution { public int lengthOfLongestSubstring(String s) { if(s == null || s.length()== 0){ return 0; } int left = 0; int right = 0; int sequenceLen = 0; char[] chars = s.toCharArray(); HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); while(right &lt; chars.length) { char curr = chars[right]; if (map.containsKey(curr) &amp;&amp; map.get(curr) &gt;=left) { // if we found a duplicated item, we update sequenceLen and move the left pointer. // we need to assure that map.get(curr) &gt;= left as the curr character sequence is from index-left to index-right. sequenceLen = Math.max(right - left, sequenceLen); left = map.get(curr) + 1; }else{ // in the above, we only update the length value when we found a duplicated item, but if we have reached the last item in the array and there is no duplicated charaters, we still need to update the length value. for example: [a,a,b]. if(right == chars.length-1){ sequenceLen = Math.max(right - left + 1, sequenceLen); } } map.put(curr, right); right++; } return sequenceLen; }}","link":"/2022/12/16/Leetcode-3-Longest-Substring-Without-Repeating-Characters/"},{"title":"notes-JavaWeb","text":"1. Tomcaterror1: 404 I think there are some problems with the version of the Tomcat. My local tomcat is 8.5.50, but the version shown on the 404 page is 9.0.68(which is the version of the Tomcat in the bilibili -clone project. ) Although I think the version of tomcat in these 2 projects don’t impact each other… but to solve this 404 problem, I decided to download Tomcat 9.0.68. Then errro2 appears…. error2 : Cannot find ./catalina.sh,The file is absent or does not have execute permission the reason is that I don’t have the permission to execute that file. solution: 1chmod +x *.sh After making this error disappear, the 404 error also disappears… 2. a simple servlet demoservlet can be seen as a component between request and DAO. For example, assume that we submit a form with “action=addUser” then a servlet named “addUser” helps us resolve the data from the request and give those data to UserDAO. a simple demo: 12345&lt;!-- html --&gt; &lt;form method=\"post\" action=\"/addUser\"&gt; name： &lt;input name=\"name\"&gt; &lt;button type=\"submit\"&gt;submit&lt;/button&gt; &lt;/form&gt; servlet 123456public class AddUserServlet extend HttpServlet { @Override protected void doPost(httpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String name = req.getParameter(\"name\"); System.our.println(\"name is: \" + name)} To bind the form post request and the servlet, we need to add some configuration in web.xml file. 123456789&lt;servlet&gt; &lt;servlet-name&gt;addUser&lt;/servlet-name&gt; &lt;servlet-class&gt;com.demo.servlet.AddUserServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;addUser&lt;/servlet-name&gt; &lt;url-pattern&gt;/addUser&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; also, after servelt 3.0, we can bind the url with servelet by annotation 1234@WebServlet(\"/url\")public class AddUserServlet extend HttpServlet {...} 3. some other points on ServletencodingIf we input Chinese or Japanese in the input filed above, the servlet can’t get the right parameter value. To solve this problem, we need to: 12request.setCharacterEncoding(\"UTF-8\");// notice that after Tomcat 8, we don't need to care about the encoding for get requests. life cycleTomcat helps us to manage the life cycle of Servlet. init() service( ) - check request method and call responding method(post =&gt; doPost) destroy() By default, a servlet was initialized after it received a request for the first time. After Tomcat was stopped, all the servelet instances will be destroyed. We could use the code below to see at what timing each method is called. 1234567891011121314151617181920public class AddUserServlet extends HttpServlet { public AddUserServlet(){ System.out.println(\"addUserServlet instance is created\"); } @Override public void init() throws ServletException { System.out.println(\"init method is called\"); } @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"service method is called\"); } @Override public void destroy() { System.out.println(\"destroy method is called\"); }} the first time we click the submit button to send a post request, the content below will be printed : 123addUserServlet instance is created init method is calledservice method is called after that, if we submitted a new post request, only the service method is called. If we ternimate Tomcat, destroy method would be called. Actually, we can change the initilazation timing of a servlet 123456&lt;servlet&gt; &lt;servlet-name&gt;... &lt;servlet-class&gt;... &lt;!-- a servet with a smaller number initializes earlier--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; For every Servlet, only one instance will be created, which means that it’s unsecure to use in multi-thread sceinarios. session managemenet create/ get session 12HttpSession session = req.getSession(); // if there is no session, then create a new sessionSystem.out.println(session.getId()); After we send a request, the server with send a sessionId back 123Response HeadersSet-Cookie: xxx Then if we send a request again, we can see Cookie in the request header. 1234Request HeadersCookie:xxx common APIs 123456request.getSession(true) // the same as request.getSession();request.getSession(false) // not create a session if there isn't one.session.isNew() // is the session is newly createdsession.getMaxInactiveInterval() // default: 1800 (1800s/30min)session.setMaxInactiveInterval(xx)session.invalidate() // forcely make the session invalidated store infromation in session attributes 123session.setAttribute(\"name\", \"Alex\");session.getAttribute(\"name\");session.removeAttribute(\"name\"); Session attributes can be used to store information about the user’s preferences, the state of the application, or any other data that need to be persisted across requests. ​ some common use cases: store user’s preferences. ex: a user’s preferred language or theme state management. ex: the process of a multi-step form./ the items in a user’s shopping cart user authentication.ex: user’s login status analytics:ex: user’s action with the application, which ca be used for analytics purpose Note that if we restart Tomcat, the session created last time will be invalidated. The reason is that the session data including session ID is typically stored in the memory on he server and the server’s memory is wiped when the application is restarted. If we want to persist session data across application restars, we can use a database to store the session data. 4. server-side forwarding &amp; client-side redirecting server-side forwarding basic process: ![image-20221217164955862](/Users/wangjingjie/Library/Application Support/typora-user-images/image-20221217164955862.png) client-side redirecting basic process: ![image-20221217170021424](/Users/wangjingjie/Library/Application Support/typora-user-images/image-20221217170021424.png) code demo 1234567&lt;form method=\"get\" action=\"/forwarding\"&gt; &lt;button type=\"submit\"&gt;forward test&lt;/button&gt;&lt;/form&gt; &lt;form method=\"get\" action=\"/redirecting\"&gt; &lt;button type=\"submit\"&gt;redirecting test&lt;/button&gt; &lt;/form&gt; 12345678910111213public class ForwardServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.getRequestDispatcher(\"/test2.html\").forward(req, resp); }}public class RedirectServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.sendRedirect(\"/test2.html\"); }} 5. thymleafbasic usage: config 123456789&lt;context-param&gt; &lt;param-name&gt;view-prefix&lt;/param-name&gt; &lt;param-value&gt;/&lt;/param-value&gt;&lt;!-- / means the directory \"web/\" --&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;view-suffix&lt;/param-name&gt; &lt;param-value&gt;.html&lt;/param-value&gt; &lt;/context-param&gt; create ViewBaseServlet and make other servlet extends it 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.demo.servlet;import org.thymeleaf.TemplateEngine;import org.thymeleaf.context.WebContext;import org.thymeleaf.templateresolver.ServletContextTemplateResolver;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class ViewBaseServlet extends HttpServlet { private TemplateEngine templateEngine; @Override /** * initialize a templateEngine */ public void init() throws ServletException { ServletContext servletContext = this.getServletContext(); ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver(servletContext); String viewPrefix = servletContext.getInitParameter(\"view-prefix\"); String viewSuffix = servletContext.getInitParameter(\"view-suffix\"); templateResolver.setPrefix(viewPrefix); templateResolver.setPrefix(viewSuffix); // set the time-to-live(TTL) value for templates that are cached by the \"servletContextTemplateResolver\" object // once a template has been processed and cached, it will remain in the cache for 60s before // it's considered stale and need to be re-processed. // This can help improve the need to re-process templates unnecessarily templateResolver.setCacheTTLMs(60000L); // 60s // templates will be cached after they are processed and the cached version will be used in subsequent requests. templateResolver.setCacheable(true); templateResolver.setCharacterEncoding(\"utf-8\"); templateEngine = new TemplateEngine(); templateEngine.setTemplateResolver(templateResolver); } /** * process a template and send the output back to the client */ protected void processTemplate (String templateName , HttpServletRequest req, HttpServletResponse resp) throws IOException { resp.setContentType(\"text/html;charset=UTF-8\"); // webContext is a context object used by the template engine to store information about the current request and response WebContext webContext = new WebContext(req, resp, getServletContext()); // process the template using data in webContext and writes the output to the response's writer object templateEngine.process(templateName,webContext, resp.getWriter()); }} 12345678910@WebServlet(\"/index\")public class IndexServlet extends ViewBaseServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { List&lt;Users&gt; users = userDao.getAll(); HttpSession session = req.getSession(); session.setAttribute(\"users\", users); super.processTemplate(\"index\", req, resp); }} write html 12345678&lt;tr th:if=\"${ #lists.isEmpty(session.users) }\"&gt; &lt;td colspan=\"2\"&gt;no data&lt;/td&gt;&lt;/tr&gt;&lt;tr th:unless=\"${ #lists.isEmpty(session.users) }\" th:each = \"user : ${session.users}\"&gt; &lt;td th:text = \"${user.name}\"&gt;&lt;/td&gt; &lt;td th:text = \"${user.hobby}\"&gt;&lt;/td&gt;&lt;/tr&gt; 6. common scopesI only mentioned seesion cope above, actually there are 2 other common scopes in Java Web. request scope: data in this scope is only valid during a single request/response cycle 123456request.setAttribute(\"name\", \"Alex\");request.sendRedirect(\"page2\"); // we can't get \"name\" by request.getAttribute(\"name\") in Page2Servlet// but things became different when it comes to server-side forwaringrequest.getRequestDispatcher(\"page2\").forward(request, response);// this time we can get the name in Page2Servlet as the request/response cycle is ended after sending repsonse from Page2Servlet application scope: data in this scope is valid for the entire lifetime of the web application ServletContext application = request.getServletContext(); application.setAttribute(\"name\", \"Alex\"); application.getAttribute(\"name\", \"Alex\");","link":"/2022/12/15/notes-JavaWeb/"},{"title":"notes-JDBC","text":"1. data persistence in Java use JDBC to access database JDO /Java Data Object third-party tools such as Hibernate and Mybatis JDBC is the basic as others encapsulated it. 2. JDBC concept full-name: Java Database connectivity JDBC offers a set of Java APIs to makes it possible to access any kinds of database in the same way by using differenct drivers. It actually offers a set of specification. Database vendors implements the Driver APIs to manipulate the data. As programmars we don’t neet to care too much about how the Driver APIs are implemented. 3.create connections add jar file create a folder called lib, put mysql-connector-jave jar file into it, then right-click the file and choose “Build Path- Add to Build Path”. 12345678Driver driver = new com.mysql.cj.jdbc.Driver();String url = \"jdbc:mysql://localhost:3306/test\"; // jdbc:protocal, mysql: sub protocal Properties info = new Properties();info.setProperty(\"user\", \"root\"); // notice that it's \"user\", not \"username\" here. info.setProperty(\"password\", \"root\");Connection conn = driver.connnet(url, info); we could do something to make the above code more elegant. 1234567// 1. create driver instance by reflectionClass clazz = Class.forName(\"com.mysql.cj.jdbc.Driver\");Driver driver = (Driver) clazz.getDeclaredConstructor().newInstance(); //xx.newInstance() is depracated;// 2. use DriverManagerDriverManager.registerDriver(driver);DriverManager.getConnetion(url, user, password); // there are several other apis here, such as getConnection(url, info) Actually, the first 3 lines of code above can be replaced with one line of code 1234567891011121314Class.forName(\"com.mysql.cj.jdbc.Driver\") // this code means that we load the MySQL Driver class into our memory. // in the source code, there is a static code block that will be executed after the class is loaded into memory. // so, Mysql Driver automatically registers the driver for us. // the relatvie source code: static { try{ java.sql.DriverManager.registerDriver(new Driver()); }catch(...){ ... }} actually, we don’t even to load the class manually! It will be automatically loaded. 123Class.forName(\"com.mysql.cj.jdbc.Driver\") // we don't need this line! // However, be aware that this dosen't apply to all vendors.(ex : Oracle).So keeping this line of code is recommended. Notice that we hard code the infomation about our database. Intead of doing this, we could put those information in a property file. create jdbc.propertiesffile in src direactory. 1234driverClass=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/testuser=rootpassword=root get info 123456789InputStream iStream = ConnectionTest.class.getClassLoader().getResourceAsStream(\"jdbc.properties\");Properties pros = new Properties();pros.load(iStream);String driverClass = props.getProperty(\"driverClass\");String url = props.getProperty(\"url\");String user = props. getProperty(\"user\");String password = props.getProperty(\"password\"); so the full final version of code is: 12345678910111213141516// read info from properties fileInputStream iStream = ConnectionTest.class.getClassLoader().getResourceAsStream(\"jdbc.properties\");Properties pros = new Properties();pros.load(iStream);String driverClass = props.getProperty(\"driverClass\");String url = props.getProperty(\"url\");String user = props. getProperty(\"user\");String password = props.getProperty(\"password\");// load Driver Class.forName(driverClass);// get a connectionConnection conn = DriverManager.getConnection(url, user, password);","link":"/2022/12/15/notes-JDBC/"},{"title":"Leetcode-9. Palindrome Number","text":"Problem StatementGiven an integer x, return true if x is a palindrome, and false otherwise. AnalysisWe can inverse the integer and check if the new integer equals to the input. But we can do better by only reversing half of it. Let’s say the input array is 123321. The bascic procedure is shown below: so the psudocode for the procedure above is something like this: 12345678int reversed_num = 0;while(something...){ reversed_num = reversed_num * 10 + num % 10; num = num / 10;}return num == reversed_num || num == reversed_num / 10 So when do we stop the loop? Notice that before we finished reversing, reversed_num &lt; num. so we could add: 1while(num &gt; reversed_num ) Also, notice that we need to consider some edge cases. if the input is a negative number, we need to do nothing but return false; if the input is 0, return true; if the last digit of the input is 0, return false. code123456789101112131415161718class Solution { public boolean isPalindrome(int num) { if(num == 0){ return true; } if(num % 10 == 0 || num &lt; 0){ return false; } int reversed_num = 0; while(num &gt; reversed_num ){ reversed_num = reversed_num * 10 + num % 10; num = num /10; } return num == reversed_num || num == reversed_num /10; }}","link":"/2022/12/17/Leetcode-9-Palindrome-Number/"},{"title":"course notes - bilibli clone","text":"Below are the notes that I took when I was learning the course “SpringBoot2.x实战B站高性能后端项目”(making a high-performance back-end project by imitating Bilibili) CHAPTER 1 project environment setup1.create a new projectThis is a multi-module project, so I need to create several modules. The basic modules in this project are: bili-api (controller) bili-service bili-dao ​ After creating the modules above, I need to create configuration files. ​ bili-api —- 2 configuration files, application-test.properties and application-online.properties. Then in the service module, create a file that contains the common configurations - application.properties 2. spring boot dependencies and dependencies between moduels (1) add SpringBoot parent denpendency and spring-web (2) dependencies between moduels : service is dependent on dao and api is dependent on service errors here: pom file in bili-api is grayed out and strikethrough ​ solution: Preferences-Maven-IgnoredFiles, uncheck the pom file. 3. launch the project (1) create a BiliApp.java file in bili-api, and add the code below 123456789@SpringBootApplicationpublic class BiliApp{ public static void main( String[] args ) { ApplicationContext app = SpringApplication.run(BiliApp.class, args); }} (2)set the profile 12# profilespring.profiles.active = test errors and problems here: “SpringBootApplication.run“ becomes red simply because I wrote SpringBootApplication instead of SpringApplication the icon before configuration file isn’t right. ref: https://blog.51cto.com/u_15441799/4675193 Exception in thread \"main\" java.lang.NoClassDefFoundError solution: I took a lot of time to search on Google, but it was still not solved. Then I noticed that the version of spring-context and the version of spring-boot were shown in the error message, so I tried to upgrade the version of spring-boot, and it worked! profile set in a applicaiton.properties is not detected, error message: No active profile set, falling back to default profiles:default solution: I set the profile in ‘Edit configuration’ window and it worked. I tested and found that the configuration file in api module can be read properly. But I’m still wondering why setting profile in the configuration file doesn’t work. tomcat jar file broken, error message: tomcat-embed-core-9.0.53.jar; zip file is empty solution: delete tomcat-embed-core from external libraries and re-add it. 4. datasource configuration and persistence layer setup(1)MySQL dependency and configurations for datasource (2) Mybatis dependency and configurations for it (3) create tesDao/controller/service error1 : Invalid bound statement (not found): org.example.dao.TestDao.findUserNameById Actually this error is linked with the profile error above. application.properties in the parent module is not read. some attemption: 1234@PropertySources({ @PropertySource(\"classpath:application.properties\")})// I tried to add this before the startup class and I got an exception :java.io.FileNotFoundException: class path resource [application.properties] cannot be opened because it does not exist So it means that the application.properties file is totally not found by my application. After reading https://blog.csdn.net/weixin_44695793/article/details/107752054, I noticed that there is no target folder in the parent directory, which means that application.properties file is not compiled. Then I opened the demonstration file from the course and tried to compare it with mine. Then I noticed that I put the application.properties file in the wrong place. It should in servcie-module. After correcting this, it seems that the problem above is solved. But there is a new problem. error2 : FileNotFoundException: class path resource [mapper/*.xml] cannot be opened because it does not exist solution: 1234mybatis.config-location=classpath:mapper/*.xml# I wronly wrote the configuration. The right one should be: mybatis.mapper-locations=classpath:mapper/*.xml # notice: * mapper / * locations 5. hot deployment(1)preferences- compiler - check build project automatically (2) command + option +shift + / open Maintenance window, click ‘registry’, check the following two options: compiler.document.save.enabled compiler.automake.allow.when.app.runningi(for newer edition of IDEA, go to Preferences-Advanced Settings- check ‘Allow auto-mae to start even if deveploped application is currently running’) (3)click edit-configuration ​ change ‘on Update action’ and ‘on frame deactivation’ to ‘update classes and resources’. (4) add spring-devtools dependency and configuration 1spring.devtools.restart.enabled=true In fact, it didn’t work after I had followed the instructions aboved, which are given by the instructor of the course. I did what was said in https://blog.csdn.net/luokha/article/details/119746359 (check compiler-compile indepenetd modules in parallel). Then it worked.","link":"/2022/12/14/course-notes%20bilibili-clone-1/"},{"title":"course-notes bilibilib clone2","text":"chapter 2 user moduelRESTful URL conventions the path must be plural nouns . ex: /users (bad: /getUsers) try to keep all characters in lower-case form. Use - to connect words. ex: / users-fans (bad: /usersFans) some examples: GET: /users/20 =&gt; get user list POST: /users =&gt; create new user PUT: /users/20 =&gt; modify the user with id 20 PUT: /users =&gt; modify a batch ofl users DELETE: /users/20 =&gt; delete the user with id 20 some relatively complex GET API users?gender=male&amp;sort=created-time-desc =&gt; filter + sort users?size=10&amp;no=1 =&gt; pagination Packaging response data create a class in domain package in Dao 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.bili.domain;public class JsonResponse&lt;T&gt; { private String code; private String msg; private T data; public JsonResponse(String code, String msg){ this.code =code; this.msg = msg; } public JsonResponse(T data){ this.data = data; this.msg = \"success\"; this.code = \"0\"; } public static JsonResponse&lt;String&gt; success(){ return new JsonResponse&lt;&gt;(null); } public static JsonResponse&lt;String&gt; success(String data){ return new JsonResponse&lt;&gt;(data); } public static JsonResponse&lt;String&gt; failed(){ return new JsonResponse&lt;&gt;(\"1\", \"failed\"); } public static JsonResponse&lt;String&gt; failed(String code, String msg){ return new JsonResponse&lt;&gt;(code ,msg); } public String getCode() { return code; } public String getMsg() { return msg; } public T getData() { return data; } public void setCode(String code) { this.code = code; } public void setMsg(String msg) { this.msg = msg; } public void setData(T data) { this.data = data; }} create a HttpMessageConverter 123456789101112131415161718192021222324252627282930package com.bili.service.config;// @Configuration is used to indicate that a class contains bean definition for the application context.// this class is used to create and configure the \"HttpMessageConverters\" bean.@Configurationpublic class JsonHttpMessageConverterConfig { @Bean // @Primary indicated that the bean should be given priority over any other beans of the same type // that may be defined in the application context @Primary public HttpMessageConverters fastJsonHttpConverters(){ //FastJsonHttpMessageConverter is a custom HttpMessageConverter implementation to convert between JSON and Java objects. FastJsonHttpMessageConverter converter = new FastJsonHttpMessageConverter(); FastJsonConfig config = new FastJsonConfig(); config.setDateFormat(\"yy MM dd HH:mm:ss\"); config.setSerializerFeatures( SerializerFeature.PrettyFormat, // sometimes null strings are still needed to be displayed on the page as empty string; // the same with list, map, etc. SerializerFeature.WriteNullStringAsEmpty, SerializerFeature.WriteNullListAsEmpty, SerializerFeature.WriteMapNullValue, SerializerFeature.MapSortField, // disable circular reference SerializerFeature.DisableCircularReferenceDetect ); converter.setFastJsonConfig(config); return new HttpMessageConverters(converter); }} In the above, we disabled circular reference. But what does circular reference mean? Take a look at the code below. 123456789List&lt;Object&gt; list = new ArrayList&lt;&gt;(); Object obj = new Object(); list.add(obj); list.add(obj); System.out.println(JSONObject.toJSONString(list)); // [{},{\"$ref\":\"$[0]\"}] =&gt; not what we want. System.out.println(JSONObject.toJSONString(list, SerializerFeature.DisableCircularReferenceDetect)); // [{},{}] global exception handler create a domain named “ConditionException” to encapsulate common exceptions. 12345678910111213141516171819202122232425package com.bili.domain.exception;public class ConditionException extends RuntimeException{ private static final long serialVersionUID = 1L; private String code; public ConditionException(String code, String name){ super(name); this.code = code; } public ConditionException(String name){ super(name); code = \"500\"; } public String getCode(){ return code; } public void setCode(String code) { this.code = code; }} create a handler 12345678910111213141516171819202122232425262728package com.bili.service.handler;import javax.servlet.http.HttpServletRequest;// ControllerAdvice is used to define global exception handling for controller.// methods defined here will be called whenever an exception is thrown from a controller method@ControllerAdvice// The order annotation is often used in conjunction with exception handling to specify priority of methods.@Order(Ordered.HIGHEST_PRECEDENCE)public class CommonGlobalExceptionHandler { @ExceptionHandler(value = Exception.class) // @ResponseBody is used to indicate that the return value of a method should be written directly to the HTTP response body. @ResponseBody // order can be used before a method. ex: @order(1)-- lower number, higher priority // why write HttpServletRequest here? // it's common to write it because HttpServletRequest can give us some information about the // Http request that caused the exception. public JsonResponse&lt;String&gt; commonExceptionHandler(HttpServletRequest req, Exception e){ String errMessage = e.getMessage(); if(e instanceof ConditionException){ ConditionException ex = (ConditionException) e; return new JsonResponse&lt;&gt;(ex.getCode(), errMessage); }else{ return new JsonResponse&lt;&gt;(\"500\", errMessage); } }} add some utils ​ here I add 3 util classes, which are for encryption and decryption 1. user accountbasic login /register logic create user table and user-info table create corresponding domain classes register basic logic 1234567891011121314151617181920212223242526272829303132333435363738394041public void addUser(User user) { // data validation String phone = user.getPhone(); if(phone == null || phone.isBlank()){ throw new ConditionException(\"phone number cannot be empty\"); } if(getUserByPhone(phone)!=null){ throw new ConditionException(\"this phone number has been registered\"); } // generate Md5Password Date timeNow = new Date(); String salt = String.valueOf(timeNow.getTime()); String passwordRaw; try{ passwordRaw = RSAUtil.decrypt(user.getPassword()); }catch (Exception e){ throw new ConditionException(\"password decryption failed\"); } String md5Password = MD5Util.sign(passwordRaw, salt, \"UTF-8\"); // set data user.setSalt(salt); user.setPassword(md5Password); user.setCreateTime(timeNow); // addUser userDao.addUser(user); // set userInfo data and add UserInfo UserInfo userInfo = new UserInfo(); userInfo.setUserId(user.getId()); userInfo.setNick(UserConstant.DEFAULT_NICK); userInfo.setBirth(UserConstant.DEFAULT_BIRTH); userInfo.setGender(UserConstant.GENDER_UNKNOWN); userInfo.setCreateTime(timeNow); userDao.addUserInfo(userInfo); } login 123456789101112131415161718192021222324252627282930313233343536// controller@PostMapping(\"/user-tokens\")public JsonResponse&lt;String&gt; login(@RequestBody User user){ String token = userService.login(user); return JsonResponse.success(token);}// service public String login(User user) { // validation String phone = user.getPhone(); if(phone == null || phone.isBlank()){ throw new ConditionException(\"Phone number cannot be empty\"); } User userDb = getUserByPhone(phone); if(userDb == null){ throw new ConditionException(\"This phone number has not been registered\"); } // passsword String passwordRaw; try{ passwordRaw = RSAUtil.decrypt(user.getPassword()); }catch (Exception e){ throw new ConditionException(\"Password decryption failed\"); } String passwordMd5 = MD5Util.sign(passwordRaw, userDb.getSalt(), \"UTF-8\"); if(!passwordMd5.equals(userDb.getPassword())){ throw new ConditionException(\"The phone number and password don't match\"); } // return token return TokenUtil.generateToken(userDb.getId()); } JWT token authentication some information on session-based authentication basic process user login =&gt; the server creates a new session and assigns a session identifier to the user (a sesseion identifier is usually a randomly generated string that is stored on the server and associated with a particuar user) =&gt; the session identifier is stored in a cookie on the user’s computer =&gt; subsequent request : user send the cookie =&gt; the server use the session identifier to look up the user’s sesson and verity their identity drawbacks statefulness: it requries the server to store information about each user’s session, ex: session identifiers, login credentials, user’s permissions… security: session identifiers are stored in cookies, so they are vulneralbel to certain types of attacks. scalability: it can be challenging to main session state acrpss multiple servers. JWT token authentication introduction JWT: JSON Web token. It’s a standard for representing claims securely. 3 parts : (1)header: 2 parts =&gt; the type of the token(JWT), the signing algorithm (2)payload: contains the claims, which are statements about an entity(ex:user) and additional data (3)signature an example: 123456789101112131415161718192021222324Header:{ \"alg\": \"HS256\", \"type\": \"JWT\"}Encoded Header: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9payload: { \"name\": \"John Doe\", \"iat\": 1516239022 // issued at }Encoded payload: eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQSecret: secret // a string known only to the issuer and the recipient of the JWT Signature: XbPfbIHMI6arZ3Y922BhjWgQzWXcXNrz0ogtVhfEd2o// the signature is created by signing the encoded Header, the encoded payload and the secret with// the algorithm specified in the header so the complete token is : eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.XbPfbIHMI6arZ3Y922BhjWgQzWXcXNrz0ogtVhfEd2o JWT token authentication code 123456789101112131415161718192021222324252627282930313233343536package com.bili.service.util;public class TokenUtil { private static final String ISSUER = \"ISSUER\"; public static String generateToken(Long userId) throws Exception { Algorithm algorithm = Algorithm.RSA512(RSAUtil.getPublicKey(), RSAUtil.getPrivateKey()); // Calendar provides a convenient way to perform date and time arithmetic // such as the add operation below Calendar calendar = Calendar.getInstance(); calendar.setTime(new Date()); calendar.add(Calendar.SECOND, 30); return JWT .create() .withKeyId(String.valueOf(userId)) .withIssuer(ISSUER) .withExpiresAt(calendar.getTime()) .sign(algorithm); } public static Long verifyToken(String token){ try{ Algorithm algorithm = Algorithm.RSA512(RSAUtil.getPublicKey(), RSAUtil.getPrivateKey()); JWTVerifier verifier = JWT.require(algorithm).build(); DecodedJWT jwt = verifier.verify(token); String userId = jwt.getKeyId(); return Long.valueOf(userId); }catch (TokenExpiredException e){ throw new ConditionException(\"555\", \"token expired\"); }catch (Exception e){ throw new ConditionException(\"illegal token\"); } }} getUserIo12345678@GetMapping(\"/users\")public JsonResponse&lt;User&gt; getUserInfo(){ Long userId = userSupport.getCurrentUserId(); User user = userService.getUserById(userId); UserInfo userInfo = userService.getUserInfoByUserId(userId); user.setUserInfo(userInfo); return new JsonResponse&lt;&gt;(user);} 12345678910111213141516171819202122// UserSupportpackage com.bili.api.support;import com.bili.domain.exception.ConditionException;import com.bili.service.util.TokenUtil;import org.springframework.stereotype.Component;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;@Componentpublic class UserSupport { public Long getCurrentUserId(){ ServletRequestAttributes requestAttributes= (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); String token = requestAttributes.getRequest().getHeader(\"token\"); Long userId = TokenUtil.verifyToken(token); if(userId &lt; 0){ throw new ConditionException(\"illegal userId\"); } return userId; }} update user / userInfothe basic logic: 123456789@PutMapping(\"/users\")public JsonResponse&lt;String&gt; updateUsers(@RequestBody User user) throws Exception { Long userId = userSupport.getCurrentUserId(); System.out.println(user.getPhone()); user.setId(userId); userService.updateUsers(user); return JsonResponse.success();} 123456789101112131415// servicepublic void updateUsers(User user) throws Exception { Long id = user.getId(); User userDb = userDao.getUserById(id); if(userDb == null) { throw new ConditionException(\"This user does not exist\"); } if(user.getPassword() != null &amp;&amp; !user.getPassword().isBlank()){ String passwordRaw = RSAUtil.decrypt(user.getPassword()); String passwordMd5 = MD5Util.sign(passwordRaw, userDb.getSalt(), \"UTF-8\"); user.setPassword(passwordMd5); } user.setUpdateTime(new Date()); userDao.updateUsers(user);} 2. user follow moduleHere we create 2 tables and corresponding entities: user_follwing : the information about followees and followers, the key columns are : userId, followingId, groudId following_group: store information about follow group type.ex: “default”, “special”, “quietly” adding a following relationship1234567891011/** * add a following relationship */@PostMapping(\"/user-following\")public JsonResponse&lt;String&gt; addUserFollowing(@RequestBody UserFollowing userFollowing){ Long userId = userSupport.getCurrentUserId(); userFollowing.setUserId(userId); userFollowingService.addUserFollowing(userFollowing); return JsonResponse.success();} 1234567891011121314151617181920212223242526272829// service@Transactionalpublic void addUserFollowing(UserFollowing userFollowing){ // check groupId Long groupId =userFollowing.getGroupId(); if( groupId == null){ Long defaultGroupId = followingGroupService.getByType(UserConstant.USER_FOLLOWING_GROUP_TYPE_DEFAULT).getId(); userFollowing.setGroupId(defaultGroupId); }else{ FollowingGroup followingGroupDb = followingGroupService.getById(groupId); if(followingGroupDb == null){ throw new ConditionException(\"The following group does not exist.\"); } } // check if the user a user wants to follow exists User followingUserDb = userService.getUserById(userFollowing.getFollowingId()); if(followingUserDb == null){ throw new ConditionException(\"The user you are trying to follow does not exist.\"); } // delete the existing following relationship first // prevent duplicate follow relationships; userFollowingDao.deleteUserFollowing( userFollowing.getUserId(), userFollowing.getFollowingId()); // add userFollowing.setCreateTime(new Date()); userFollowingDao.addUserFollowing(userFollowing);} get Followee-List and Follower-List GET: /user-following When we fetch the list about the whom a user is following, we not only need to fetch their ids, but also some other information, such as: the following group they belong to, their information. So instead of provide List&lt;UserFollowing&gt; or List&lt;UserInformation&gt; to the frontend, it’s better to provide the data List&lt;FollowingGroup&gt; So the method in UserFollowingApi or UserFollowingController is: 1234567@GetMapping(\"/user-following\") public JsonResponse&lt;List&lt;FollowingGroup&gt;&gt; getUserFollowings(){ Long userId = userSupport.getCurrentUserId(); List&lt;FollowingGroup&gt; userFollowingList = userFollowingService.getUserFollowings(userId); return new JsonResponse&lt;&gt;(userFollowingList); } userFollowingService 12345678910111213141516171819202122232425262728293031323334353637383940414243public List&lt;FollowingGroup&gt; getUserFollowings(Long userId) { // 1. get FollowingList List&lt;UserFollowing&gt; userFollowingList = userFollowingDao.getUserFollowings(userId); // 2. get and set corresponding userInfo Set&lt;Long&gt; followingIdSet = userFollowingList.stream().map(UserFollowing::getFollowingId).collect(Collectors.toSet()); List&lt; UserInfo&gt; userInfoList = new ArrayList&lt;&gt;(); if(followingIdSet.size() &gt; 0){ userInfoList = userService.getUserInfoByUserIds(followingIdSet); } for (UserFollowing userFollowing : userFollowingList) { for (UserInfo userInfo : userInfoList) { if(userFollowing.getFollowingId().equals(userInfo.getUserId())){ userFollowing.setUserInfo(userInfo); } } } // 3. get and set group info // (1)create a group which contains all following users. // this group does not need to be stored in the database FollowingGroup followingGroupAll = new FollowingGroup(); followingGroupAll.setName(\"all\"); followingGroupAll.setFollowingUserInfoList(userInfoList); List&lt;FollowingGroup&gt; result = new ArrayList&lt;&gt;(); result.add(followingGroupAll); // (2) set userInfo for other groups List&lt;FollowingGroup&gt; followingGroupList = followingGroupService.getByUserId(userId); for (FollowingGroup group : followingGroupList) { List&lt;UserInfo&gt; infoList = new ArrayList&lt;&gt;(); for (UserFollowing userFollowing : userFollowingList) { if(group.getId() .equals(userFollowing.getGroupId())){ infoList.add(userFollowing.getUserInfo()); } } group.setFollowingUserInfoList(infoList); result.add(group); } return result; } get followers 12345678910111213141516171819202122232425262728293031public List&lt;UserFollowing&gt; getUserFollowers(Long userId){ // 1. get followerList (&lt;UserFollowing&gt;) List&lt;UserFollowing&gt; followerList = userFollowingDao.getUserFollowers(userId); // 2. get userInfo Set&lt;Long&gt; followerIdSet = followerList.stream().map(UserFollowing::getUserId).collect(Collectors.toSet()); List&lt;UserInfo&gt; userInfoList = new ArrayList&lt;&gt;(); if(followerList.size( ) &gt; 0){ userInfoList = userService.getUserInfoByUserIds(followerIdSet); } // 3. get followee data List&lt;UserFollowing&gt; userFollowingList = userFollowingDao.getUserFollowings(userId); // 4. set userInfo and check if is mutual follow for (UserFollowing follower : followerList) { for (UserInfo userInfo : userInfoList) { if(follower.getUserId().equals(userInfo.getUserId())){ follower.setMutualFollow(false); // initialize the value follower.setUserInfo(userInfo); } } for (UserFollowing userFollowing : userFollowingList) { if(userFollowing.getFollowingId().equals(follower.getUserId())){ follower.setMutualFollow(true); } } } return followerList;} add ang get FollowGroupsthis one is very simple, so I don’t need to write any notes here. get paginated user informationThis is maily for search users with or without a nickname keyword. 123456789101112131415161718@GetMapping(\"/user-infos\") public JsonResponse&lt;PageResult&lt;UserInfo&gt;&gt; getUserInfos(@RequestParam Integer pageNum, @RequestParam Integer pageSize, @RequestParam(required = false) String nick){ Long userId = userSupport.getCurrentUserId(); JSONObject params = new JSONObject(); params.put(\"pageNum\", pageNum); params.put(\"pageSize\", pageSize); params.put(\"nick\", nick); PageResult&lt;UserInfo&gt; userInfoPageResult = userService.getUserInfos(params); // check the following relationship if(userInfoPageResult.getTotal() &gt; 0){ List&lt;UserInfo&gt; checkedResult = userFollowingService.checkFollowingRelationship(userInfoPageResult.getList(), userId); userInfoPageResult.setList(checkedResult); } return new JsonResponse&lt;&gt;(userInfoPageResult); } 12345678910111213141516public PageResult&lt;UserInfo&gt; getUserInfos(JSONObject params) { Integer pageNum = params.getInteger(\"pageNum\"); Integer pageSize = params.getInteger(\"pageSize\"); Integer offset = ( pageNum - 1) * pageSize; params.put(\"offset\", offset); String nick = params.getString(\"nick\"); List&lt;UserInfo&gt; userInfoList = new ArrayList&lt;&gt;(); // the reason that we check if there are any entries whose nickname include nick is that: // the performance of count is better by select entries Integer count = userDao.getUserInfoWithNick(nick); if(count &gt; 0){ userInfoList = userDao.getUserInfos(params); } return new PageResult&lt;UserInfo&gt;(count, userInfoList); } Errors here: java.lang.IllegalStateException: org.apache.rocketmq.remoting.exception.RemotingConnectException: connect to [127.0.0.1:9876] failed To use RocketMQ, we need not only add the RocketMQ dependency in our Java projects, but also need to install it and start the local server. 3.RBAC","link":"/2022/12/16/course-notes-bilibili-clone2/"},{"title":"Spring notes","text":"a simple demoThe jar file we need here are : spring-beans spring-context spring-core spring-expression common-logging create a class named User create applicationContext.xml and config the bean 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE beans PUBLIC \"-//SPRING//DTD BEAN 2.0//EN\" \"http://www.springframework.org/dtd/spring-beans-2.0.dtd\"&gt;&lt;beans&gt; &lt;!-- bean definitions here --&gt; &lt;bean id=\"specialUser\" class=\"org.example.entity.User\"&gt; &lt;property name=\"hobby\" value=\"archery\"/&gt; &lt;property name=\"name\" value=\"Alex\"/&gt; &lt;/bean&gt; &lt;!-- we can also use the p naming space --&gt; &lt;bean id=\"specialUser\" class=\"org.example.entity.User\" p:name=\"Alex\" p:hobby=\"archery\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 3.get the bean 12345678910111213141516public class App { public static void main( String[] args ) { ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); // getBean method returns an Object. // The ApplicationContext does not know the actual type of the bean at runtime // The ApplicationContext uses reflection to create a bean. // Although we defined a bean in the xml file and specified the class that should be used to create the bean. // this class is not loaded and initialized until the bean is actually requested from the ApplicationContext User user = (User)context.getBean(\"specialUser\"); //or User user = (User)context.getBean(\"specialUser\", User.class); // if there is only one instance configured in xml, then we can use: User user2 = context.getBean(User.class); System.out.println(user); //User{name='Alex', hobby='archery'} }} some terms: bean a Java object that is managed by the Spring container, which is responsible for instanitating, configuring and assembling the beans. ApplicationContext the central interface within a Spring application for providing cofiguration to the application. It represents the Spring container. IoC and DIInvertion of Control: in an Ioc-based system, the objects that make up the application don’t create or manage their dependencies direclty. Instead, they rely on an external IoC container to provide the objects. One way to implement Ioc in Spring is through DI(Dependency Injection). DI is a pattern means that an object’s denpendencies are injected into it, rathen than the object creating or looking up its dependencies itself. a demo piece of code of the use of DI 123456// servicepublic class UserService { public String getUserName(){ return \"Alex\"; }} 1234567891011121314151617181920 // controllerpublic class UserController { private UserService userService; //At runtime, the Spring Ioc container will create the UserService Object and inject into UserController public UserController(UserService userService) { this.userService = userService; } //We can also use the setter to inject public void setUserService(UserService userService) { this.userService = userService; } public void printName(){ String name = this.userService.getUserName(); System.out.println(name); }} 12345678910111213141516171819// xml &lt;bean id=\"userController\" class=\"org.example.controller.UserController\"&gt; &lt;constructor-arg ref=\"userService\"/&gt; &lt;/bean&gt; &lt;bean id=\"userService\" class=\"org.example.service.UserService\"&gt; &lt;/bean&gt; // or &lt;bean id=\"userController\" class=\"org.example.controller.UserController\"&gt; &lt;constructor-arg index=\"0\"&gt; &lt;bean class=\"org.example.service.UserService\"/&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; // or using autowire &lt;bean id=\"userController\" class=\"org.example.controller.UserController\" autowire=\"byName\"/&gt; &lt;bean id=\"userService\" class=\"org.example.service.UserService\"/&gt; 123456789// testpublic class UserControllerTest { @Test public void testUserController(){ ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserController controller =(UserController) context.getBean(\"userController\"); controller.printName(); // Alex }} The central interfacie in the Spring Ioc container is the BeanFactory interface. There are several implementations of it in Spring, such as ApplicationContext, which we used above. configure collection properties list(set is basically the same) 1234567891011121314151617181920212223&lt;bean id=\"userC\" class=\"org.example.entity.UserHasCollectionProperties\"&gt; &lt;property name=\"name\" value=\"Alex\"/&gt; &lt;property name=\"favouriteBooks\"&gt; &lt;list&gt; &lt;ref bean=\"book1\"/&gt; &lt;ref bean=\"book2\"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"hobbies\"&gt; &lt;list&gt; &lt;value&gt;archery&lt;/value&gt; &lt;value&gt;skiing&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; //or use the util naming space &lt;util:list id=\"bookList\" value-type=\"org.example.entity.Book\"&gt; &lt;ref bean=\"book1\"/&gt; &lt;ref bean=\"book2\"/&gt; &lt;/util:list&gt;&lt;property name=\"books\" ref=\"bookList\"/&gt; map 12345678&lt;bean id=\"userWithMap\" class=\"org.example.entity.UserWithMap\"&gt; &lt;property name=\"books\"&gt; &lt;map&gt; &lt;entry key=\"favourite\" value-ref=\"book1\"/&gt; &lt;entry key=\"disliked\" value-ref=\"book2\"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; FactoryBean There are 2 kinds of beans in Spring, regular beans and facotory beans. The beans we listed above are all regular beans. A factory bean is a special type of bean that is used to create other beans. demo code: 123456789101112131415161718192021222324public class UserFactory implements FactoryBean&lt;User&gt; { private String name; // this is a must if you want set the name by xml public void setName(String name) { this.name = name; } @Override public User getObject() throws Exception { User user = new User(); user.setName(name); return user; } @Override public Class&lt;?&gt; getObjectType() { return User.class; } @Override public boolean isSingleton() { return true; } 123&lt;bean id=\"superUser\" class=\"org.example.factories.UserFactory\"&gt; &lt;property name=\"name\" value=\"Alex\"/&gt; &lt;/bean&gt; notice that the bean created is a User, not a UserFactory 1User user= context.getBean(\"superUser\", User.class); bean scopes singleton default scope, it’s created when the spring contaier is created. prototype a new instance will be created every time a client request it. request a new instance will be created for each HTTP request session a new instance will be created for each HTTP session. application the instance is only valid with a single application context websocket a new bean is created for each WebSocket connection the life cycle of a beanthe process of Spring manaing the life cycle of a bean: create the bean instance set properties for the bean call the init method of the bean destroy the bean (using the init-method and destroy-method attributes in the bean definition) we can also use bean post processors to add two more life cycle phases : before init / after init bean post processor: allows to perform cutom logic before and after then initialization and destruction of a bean. 123456789101112131415161718public class UserPostProcessor implements BeanPostProcessor { @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { User currUser = (User) bean; System.out.println(\"curr\" + currUser); if(currUser.getName() != null){ System.out.println(\"not null name\"); currUser.setName(\"specialUser:\"+currUser.getName()) ; } return currUser; } @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { return bean; }} annotions and component-scanIf we wan to use the annotations to register a class as a compoent, we need to config componentScan. One way of doing this is to configure in the xml file 1&lt;context:component-scan base-package=\"org.example.service\"/&gt; also, we can exclude/include some specified components 12345678910&lt;context:component-scan base-package=\"org.example\"&gt; &lt;!-- exclude classes with @Service --&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Service\"/&gt; &lt;!-- exclude class UserService --&gt; &lt;context:exclude-filter type=\"assignable\" expression=\"org.example.service.UserService\"/&gt; &lt;!-- exclude with aspectJ/ need aspectJ dependency--&gt; &lt;context:exclude-filter type=\"aspectj\" expression=\"org.example.service.*Service+\"/&gt; &lt;context:exclude-filter type=\"regex\" expression=\"org.example.service.*Service+\"/&gt;&lt;/context:component-scan&gt; AOPlet’s start from a simple Calculator class. 12345public interface Calculator{ int add(int num1, int num2); int sub(int num1, int num2);} 123456789101112131415package org.example.aop;public class SimpleCalculator implements Calculator{ @Override public int add(int num1, int num2) { return num1 + num2; } @Override public int sub(int num1, int num2) { return num1 - num2; }} Now we want to have a feature that before each operation, we print the operation name and after each operation, we print the result. One way of doing is this is to hard code this in Calculator class. Also, we can use Proxy. 123456789101112131415161718192021222324package org.example.aop;public class ProxyUtil { private SimpleCalculator simpleCalculator; public ProxyUtil(SimpleCalculator simpleCalculator) { this.simpleCalculator = simpleCalculator; } public Object getProxy(){ ClassLoader classLoader = this.getClass().getClassLoader(); Class[] interfaces = simpleCalculator.getClass().getInterfaces(); return Proxy.newProxyInstance(classLoader, interfaces, new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\"the operation is: \" + method.getName()); Object result = method.invoke(simpleCalculator,args); System.out.println(result); return result; } }); }} 123456789101112 @Test public void testProxy(){ ProxyUtil proxyUtil = new ProxyUtil(new SimpleCalculator()); // we can only create Proxy for interfaces; Calculator calculator = (Calculator) proxyUtil.getProxy(); calculator.add(1,2); }// console// the operation is: add// 3 is a We can also use AOP. AOP(Aspect-oriented Programming) is a programming diagram that focues on the seperation of cross-cutting concert, or conercerns that cut acroos multiple components of a software system. These concers minght includ logging, security, or performace monitor. For example, in AOP, these concerns are modularized into “aspects” that can be woven into the main program code at compile-time, runtime, or both. dependencies we need here: cglb aopalliance aspects.weawer spring-aop spring-aspects","link":"/2022/12/19/spring-notes/"},{"title":"Leetcode-5-Longest Palindromic Substring","text":"Problem Statement Given a string s, return the longest palindromic substring in s. Example 1: 123Input: s = \"babad\"Output: \"bab\"Explanation: \"aba\" is also a valid answer. Example 2: 12Input: s = \"cbbd\"Output: \"bb\" Analysisbrute forceThe brute force method of solving this problem is to pick all possible substrings and check if each one is a palindromic. To get the time complexity of this method, first we need to know how many substrings are there. for any substring of length k (1&lt;= k &lt;= n), there are (n-k+1) ways to choose the starting position. For example, if the input is “abcdef”, the possible substrings are: length1: 6 length2: ab, bc,cd, de, ef 5 length3: abc, bcd, cde, def 4 length4: abcd, bcde, cdef 3 length5: abcde, bcdef 2 length6: 1 The number of possible substrings are : 6+ 5 + 4 + 3+ 2 + 1. For a susbstring of lengh n, the number would be n + (n-1) + … + 1, which is an arithmetic sequence and equals to (n * (n+ 1)) /2. For each substring, we still need to iterate over it and check if it’s a palindromic, which takes O(n) time Therefore, the total time complexity is O(n^3). Dynamic ProgrammingCode","link":"/2022/12/18/Leetcode-5-Longest-Palindromic-Substring/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","link":"/tags/Leetcode/"},{"name":"course-notes","slug":"course-notes","link":"/tags/course-notes/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"JDBC","slug":"JDBC","link":"/tags/JDBC/"},{"name":"JavaWeb","slug":"JavaWeb","link":"/tags/JavaWeb/"},{"name":"Spring Framework","slug":"Spring-Framework","link":"/tags/Spring-Framework/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","link":"/categories/Leetcode/"},{"name":"course-notes","slug":"course-notes","link":"/categories/course-notes/"}]}